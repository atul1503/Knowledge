Notes:
1. Settings.py path is determined first from environment variable then if you have defined in manage.py file the path of settings.py file. Even in manage.py also you use os.envrion only to set settings.py module path.
2. You can use different settings.py for different environements.
3. If any settings is missing from your settings.py file it will be fetched from the default settings.py that comes with django or if you are using an external library then the library might have provided the default value, it will take that in worst case.
4. Middlewares are packages which are executed in the order they are defined in settings.py. Requests are processesed from top to bottom and then it reaches its view. For response it is processes bottom to top of middlesware after sent by view.
5. Each middleware class has __init__ method and __call__ method. Init gets called on propject startup and call gets called on each request. In init method you are provided with the callback function that you will call to call either the next middleware or the view directly if there is no middleware next. this callback returns the response. this reponse is from the view itself although it may also get modified by other middlewares along the way.
6. Signals objects are objects that have `send()` function which is used to send these signals. There is a receiver that you can register that will be configured to receive these signals. Create a `Signal` object in sender app and then import it in receiver app apps.py and then in the read() function of the receiver object import it. Now in the receiver app, declare a function with `@receiver(signal_name)` this function will be triggered everytime a singal is sent by the sender app. Sender can pass any number of args in the `send()` call. First pass the class object of the sender class and then pass any other objects that need to be sent as keyword arg. The receiver function which got annoated will have access to those args as its own argumment.
7. Serializers in drf helps to serialize(convert complex python objects like class instances or model instances or queryset instances to python native datatypes like list,dict) or desrialize the complex python objects so that they can be easily converted to json or other format for storage or transportation. You do that with decalring a class with `serializers.Serializer` subclass and declaring fields directly inside the class as static fields. These fields are looked up when serialling or deserializing data.
8. For realtionssips, in django, define relationship in just one model with `OneToOneField` or `ManyToManyField` and `ForeignKey` fields with on_delete arg set to either models.CASCADE(to delete the connected entity on the deletion of this object) or models.PROTECT(to not delete). Use `related_name` to set set what name does the other entity refer to use this relationship.
